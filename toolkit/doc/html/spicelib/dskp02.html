
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>dskp02</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>dskp02</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     DSKP02 ( DSK, fetch type 2 plate data )

     SUBROUTINE DSKP02 ( HANDLE, DLADSC, START, ROOM, N, PLATES )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Fetch triangular plates from a type 2 DSK segment.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/das.html">DAS</a>
     <a href="../req/dsk.html">DSK</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     DAS
     DSK
     FILES
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     IMPLICIT NONE

     INCLUDE 'dla.inc'
     INCLUDE 'dskdsc.inc'
     INCLUDE 'dsk02.inc'

     INTEGER               HANDLE
     INTEGER               DLADSC ( * )
     INTEGER               START
     INTEGER               ROOM
     INTEGER               N
     INTEGER               PLATES ( 3, * )
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     HANDLE     I   DSK file handle.
     DLADSC     I   DLA descriptor.
     START      I   Start index.
     ROOM       I   Amount of room in output array.
     N          O   Number of plates returned.
     PLATES     O   Array containing plates.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     HANDLE   is the handle of a DSK file containing a type 2
              segment from which data are to be fetched.

     DLADSC   is the DLA descriptor associated with the segment
              from which data are to be fetched.

     START    is the ID of the first plate to be fetched from the
              segment designated by HANDLE and DLADSC. The ID
              of a plate is its ordinal position within the
              segment. Plate IDs range from 1 to NP, where NP is
              the number of plates in the segment.

     ROOM     is the number of plates that can fit in the output
              PLATES array: the output array must be large enough
              to hold at least 3*ROOM integer values.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     N        is the number of plates fetched to the output
              array PLATES. N is normally in the range

                 1 : MIN( NP, ROOM )

              If an error occurs on the call, N is undefined.

     PLATES   is a contiguous set of plates. The returned
              plates are arranged in order of increasing plate
              ID. The IDs of the returned plates range from

                 START

              to

                 START + N - 1

              Each plate consists of three vertex indices. The
              correspondence of elements of PLATES with the
              elements of the set of plates contained in the
              segment is:

                 PLATES(1,1)      plate_set(1, START)
                 PLATES(2,1)      plate_set(2, START)
                 PLATES(3,1)      plate_set(3, START)
                   ...             ...
                 PLATES(1,N)      plate_set(1, START+N-1)
                 PLATES(2,N)      plate_set(2, START+N-1)
                 PLATES(3,N)      plate_set(3, START+N-1)

              If an error occurs on the call, PLATES is
              undefined.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     See the include file

        dla.inc

     for declarations of DLA descriptor sizes and documentation of the
     contents of DLA descriptors.

     See the include file

        dskdsc.inc

     for declarations of DSK descriptor sizes and documentation of the
     contents of DSK descriptors.

     See the include file

        dsk02.inc

     for declarations of DSK data type 2 (plate model) parameters.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If the input handle is invalid, an error is signaled by a
         routine in the call tree of this routine.

     2)  If a file read error occurs, the error is signaled by a
         routine in the call tree of this routine.

     3)  If the input DLA descriptor is invalid, the effect of this
         routine is undefined. The error *may* be diagnosed by
         routines in the call tree of this routine, but there are no
         guarantees.

     4)  If ROOM is non-positive, the error SPICE(VALUEOUTOFRANGE)
         is signaled.

     5)  If START is less than 1 or greater than the number of plates
         in the segment, the error SPICE(INDEXOUTOFRANGE) is signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     See input argument HANDLE.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine enables SPICE-based user applications to rapidly
     fetch the plate data from a specified type 2 DSK segment. Using
     a large output array generally improves efficiency.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for this example may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine
     specific arithmetic implementation.

     1) Look up all the vertices associated with each plate
        of the model contained in a specified type 2 segment. For each
        plate, display the plate's vertices and normal vector.

        For this example, we'll show the context of this look-up:
        opening the DSK file for read access, traversing a trivial,
        one-segment list to obtain the segment of interest.


        Example code begins here.


              PROGRAM DSKP02_EX1
              IMPLICIT NONE

              INCLUDE 'dla.inc'
              INCLUDE 'dsk02.inc'


              CHARACTER*(*)         FMT
              PARAMETER           ( FMT    = '(1X,A,3(1XE15.8))' )


              INTEGER               BUFSIZ
              PARAMETER           ( BUFSIZ = 10000 )

              INTEGER               FILSIZ
              PARAMETER           ( FILSIZ = 255 )


              CHARACTER*(FILSIZ)    DSK

              DOUBLE PRECISION      NORMAL ( 3 )
              DOUBLE PRECISION      VERTS  ( 3, BUFSIZ )

              INTEGER               DLADSC ( DLADSZ )
              INTEGER               HANDLE
              INTEGER               I
              INTEGER               J
              INTEGER               N
              INTEGER               NNORM
              INTEGER               NP
              INTEGER               NREAD
              INTEGER               NV
              INTEGER               NVTX
              INTEGER               PLATES  ( 3, BUFSIZ )
              INTEGER               PLIX
              INTEGER               REMAIN
              INTEGER               START

              LOGICAL               FOUND

        C
        C     Prompt for name of DSK and open file for reading.
        C
              CALL PROMPT ( 'Enter DSK name &gt; ', DSK )

              CALL DASOPR ( DSK, HANDLE )

              CALL <a href="dlabfs.html">DLABFS</a> ( HANDLE, DLADSC, FOUND )

              IF ( .NOT. FOUND ) THEN

                 CALL <a href="setmsg.html">SETMSG</a> ( 'No segment found in file #.' )
                 CALL <a href="errch.html">ERRCH</a>  ( '#',  DSK                     )
                 CALL <a href="sigerr.html">SIGERR</a> ( 'SPICE(NOSEGMENT)'            )

              END IF

        C
        C     Get segment vertex and plate counts.
        C
              CALL <a href="dskz02.html">DSKZ02</a> ( HANDLE, DLADSC, NV, NP )

              WRITE (*,*) ' '
              WRITE (*,*) 'Number of vertices: ', NV
              WRITE (*,*) 'Number of plates:   ', NP
        C
        C     Display the vertices of the first 5 plates.
        C
              REMAIN = MIN(5, NP)
              START  = 1

              DO WHILE ( REMAIN .GT. 0 )
        C
        C        NREAD is the number of plates we'll read on this
        C        loop pass.
        C
                 NREAD  = MIN ( BUFSIZ, REMAIN )

                 CALL <b>DSKP02</b> ( HANDLE, DLADSC, START, NREAD, N,
             .                 PLATES                          )

                 DO I = 1, N

                    PLIX = START + I - 1
        C
        C           Read the vertices of the current plate.
        C
                    DO J = 1, 3
                       CALL <a href="dskv02.html">DSKV02</a> ( HANDLE, DLADSC, PLATES(J,I),
             .                       1,      NVTX,   VERTS (1,J)  )
                    END DO
        C
        C           Display the vertices of the current plate:
        C
                    WRITE (*,*  ) ' '
                    WRITE (*,*  ) 'Plate number: ', PLIX
                    WRITE (*,FMT) '   Vertex 1: ', (VERTS(J,1), J=1,3)
                    WRITE (*,FMT) '   Vertex 2: ', (VERTS(J,2), J=1,3)
                    WRITE (*,FMT) '   Vertex 3: ', (VERTS(J,3), J=1,3)

        C
        C           Display the normal vector of the current plate:
        C
                    CALL <a href="dskn02.html">DSKN02</a> ( HANDLE, DLADSC, PLIX, NORMAL )

                    WRITE (*,FMT) '   Normal:   ', (NORMAL(J), J=1,3)

                 END DO

                 START  = START  + NREAD
                 REMAIN = REMAIN - NREAD

              END DO

        C
        C     Close the kernel.  This isn't necessary in a stand-
        C     alone program, but it's good practice in subroutines
        C     because it frees program and system resources.
        C
              CALL <a href="dascls.html">DASCLS</a> ( HANDLE )

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, using the DSK file named phobos512.bds, the output
        was:


        Enter DSK name &gt; phobos512.bds

         Number of vertices:      1579014
         Number of plates:        3145728

         Plate number:            1
            Vertex 1:  -0.67744400E+01  0.62681500E+01  0.60114900E+01
            Vertex 2:  -0.67623800E+01  0.62572800E+01  0.60255600E+01
            Vertex 3:  -0.67571000E+01  0.62775400E+01  0.60209600E+01
            Normal:    -0.58197377E+00  0.32128561E+00  0.74704892E+00

         Plate number:            2
            Vertex 1:  -0.67744400E+01  0.62681500E+01  0.60114900E+01
            Vertex 2:  -0.67797300E+01  0.62479000E+01  0.60161000E+01
            Vertex 3:  -0.67623800E+01  0.62572800E+01  0.60255600E+01
            Normal:    -0.58145695E+00  0.32198831E+00  0.74714881E+00

         Plate number:            3
            Vertex 1:  -0.67797300E+01  0.62479000E+01  0.60161000E+01
            Vertex 2:  -0.67676800E+01  0.62370100E+01  0.60301900E+01
            Vertex 3:  -0.67623800E+01  0.62572800E+01  0.60255600E+01
            Normal:    -0.58159707E+00  0.32264196E+00  0.74675767E+00

         Plate number:            4
            Vertex 1:  -0.67797300E+01  0.62479000E+01  0.60161000E+01
            Vertex 2:  -0.67849900E+01  0.62276200E+01  0.60207000E+01
            Vertex 3:  -0.67676800E+01  0.62370100E+01  0.60301900E+01
            Normal:    -0.58312901E+00  0.32056070E+00  0.74645924E+00

         Plate number:            5
            Vertex 1:  -0.67849900E+01  0.62276200E+01  0.60207000E+01
            Vertex 2:  -0.67729900E+01  0.62167400E+01  0.60348200E+01
            Vertex 3:  -0.67676800E+01  0.62370100E+01  0.60301900E+01
            Normal:    -0.58366405E+00  0.32306020E+00  0.74496200E+00


        Note that only the vertex information for first 5 plates is
        provided.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman       (JPL)
     J. Diaz del Rio    (ODC Space)
     B.V. Semenov       (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.1, 08-JUL-2020 (JDR) (BVS)

        Edited the header to comply with NAIF standard. Modified code
        example to reduce the output.

    SPICELIB Version 1.0.0, 04-APR-2017 (NJB)

        Now calls ZZDDHHLU.

        Made trivial change to code example.

        DSKLIB Version 1.0.1, 22-APR-2014 (NJB)

           The diagram in the $Detailed_Output header section showing
           the contents of the output PLATES array has been corrected.

        DSKLIB Version 1.0.0, 02-JUN-2010 (NJB)</PRE>
<h4>Link to routine DSKP02 source file <a href='../../../src/spicelib/dskp02.f'>dskp02.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:36:15 2021</pre>

</body>
</html>

