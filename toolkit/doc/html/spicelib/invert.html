
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>invert</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>invert</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     INVERT ( Invert a 3x3 matrix )

     SUBROUTINE INVERT ( M, MOUT )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Generate the inverse of a 3x3 matrix.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     MATH
     MATRIX
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     IMPLICIT NONE

     DOUBLE PRECISION   M    ( 3,3 )
     DOUBLE PRECISION   MOUT ( 3,3 )
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     M          I   Matrix to be inverted.
     MOUT       O   Inverted matrix (M)**-1. If M is singular, then
                    MOUT will be the zero matrix.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     M        is an arbitrary 3x3 matrix. The limits on the size of
              elements of M are determined by the process of
              calculating the cofactors of each element of the matrix.
              For a 3x3 matrix this amounts to the differencing of two
              terms, each of which consists of the multiplication of
              two matrix elements. This multiplication must not exceed
              the range of double precision numbers or else an overflow
              error will occur.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     MOUT     is the inverse of M and is calculated explicitly using
              the matrix of cofactors. MOUT is set to be the zero
              matrix if M is singular.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     Error free.

     1)  If M is singular, MOUT is set to be the zero matrix.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     First the determinant is explicitly calculated using the
     fundamental definition of the determinant. If this value is less
     that 10**-16 then the matrix is deemed to be singular and the
     output value is filled with zeros. Otherwise, the output matrix
     is calculated an element at a time by generating the cofactor of
     each element. Finally, each element in the matrix of cofactors
     is multiplied by the reciprocal of the determinant and the result
     is the inverse of the original matrix.

     NO INTERNAL CHECKING ON THE INPUT MATRIX M IS PERFORMED EXCEPT
     ON THE SIZE OF ITS DETERMINANT.  THUS IT IS POSSIBLE TO GENERATE
     A FLOATING POINT OVERFLOW OR UNDERFLOW IN THE PROCESS OF
     CALCULATING THE MATRIX OF COFACTORS.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for this example may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine
     specific arithmetic implementation.

     1) Given a double precision 3x3 matrix, compute its inverse. Check
        that the original matrix times the computed inverse produces
        the identity matrix.

        Example code begins here.


              PROGRAM INVERT_EX1
              IMPLICIT NONE

        C
        C     Local variables.
        C
              DOUBLE PRECISION      IMAT ( 3, 3 )
              DOUBLE PRECISION      M    ( 3, 3 )
              DOUBLE PRECISION      MOUT ( 3, 3 )

              INTEGER               I
              INTEGER               J

        C
        C     Define a matrix to invert.
        C
              DATA                  M  /  0.D0,  0.5D0, 0.D0,
             .                           -1.D0,  0.D0,  0.D0,
             .                            0.D0,  0.D0,  1.D0 /

              WRITE(*,*) 'Original Matrix:'
              DO I=1, 3

                 WRITE(*,'(3F16.7)') ( M(I,J), J=1,3 )

              END DO
        C
        C     Invert the matrix, then output.
        C
              CALL <b>INVERT</b> ( M, MOUT )

              WRITE(*,*) ' '
              WRITE(*,*) 'Inverse Matrix:'
              DO I=1, 3

                 WRITE(*,'(3F16.7)') ( MOUT(I,J), J=1,3 )

              END DO

        C
        C     Check the M times MOUT produces the identity matrix.
        C
              CALL <a href="mxm.html">MXM</a> ( M, MOUT, IMAT )

              WRITE(*,*) ' '
              WRITE(*,*) 'Original times inverse:'
              DO I=1, 3

                 WRITE(*,'(3F16.7)') ( IMAT(I,J), J=1,3 )

              END DO

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, the output was:


         Original Matrix:
               0.0000000      -1.0000000       0.0000000
               0.5000000       0.0000000       0.0000000
               0.0000000       0.0000000       1.0000000

         Inverse Matrix:
               0.0000000       2.0000000      -0.0000000
              -1.0000000       0.0000000      -0.0000000
               0.0000000      -0.0000000       1.0000000

         Original times inverse:
               1.0000000       0.0000000       0.0000000
               0.0000000       1.0000000       0.0000000
               0.0000000       0.0000000       1.0000000
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1)  The input matrix must be such that generating the cofactors
         will not cause a floating point overflow or underflow. The
         strictness of this condition depends, of course, on the
         computer installation and the resultant maximum and minimum
         values of double precision numbers.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman       (JPL)
     J. Diaz del Rio    (ODC Space)
     W.M. Owen          (JPL)
     W.L. Taber         (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.1.0, 06-JUL-2021 (JDR)

        Changed input argument name M1 to M for consistency with other
        routines.

        Added IMPLICIT NONE statement.

        Updated the header to comply with NAIF standard. Added
        complete code example to $Examples section.

    SPICELIB Version 1.0.2, 22-APR-2010 (NJB)

        Header correction: assertions that the output
        can overwrite the input have been removed.

    SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (WMO)</PRE>
<h4>Link to routine INVERT source file <a href='../../../src/spicelib/invert.f'>invert.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:36:28 2021</pre>

</body>
</html>

