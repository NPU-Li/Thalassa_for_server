
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>qxq</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>qxq</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     QXQ (Quaternion times quaternion)

     SUBROUTINE QXQ ( Q1, Q2, QOUT )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Multiply two quaternions.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/rotation.html">ROTATION</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     MATH
     POINTING
     ROTATION
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     IMPLICIT NONE

     DOUBLE PRECISION      Q1   ( 0 : 3 )
     DOUBLE PRECISION      Q2   ( 0 : 3 )
     DOUBLE PRECISION      QOUT ( 0 : 3 )
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     Q1         I   First SPICE quaternion factor.
     Q2         I   Second SPICE quaternion factor.
     QOUT       O   Product of Q1 and Q2.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     Q1       is a 4-vector representing a SPICE-style
              quaternion. See the discussion of quaternion
              styles in $Particulars below.

              Note that multiple styles of quaternions
              are in use. This routine will not work properly
              if the input quaternions do not conform to
              the SPICE convention. See the $Particulars
              section for details.

     Q2       is a second SPICE-style quaternion.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     QOUT     is 4-vector representing the quaternion product

                 Q1 * Q2

              Representing Q(i) as the sums of scalar (real)
              part s(i) and vector (imaginary) part v(i)
              respectively,

                 Q1 = s1 + v1
                 Q2 = s2 + v2

              QOUT has scalar part s3 defined by

                 s3 = s1 * s2 - &lt;v1, v2&gt;

              and vector part v3 defined by

                 v3 = s1 * v2  +  s2 * v1  +  v1 x v2

              where the notation &lt; , &gt; denotes the inner
              product operator and x indicates the cross
              product operator.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     Error free.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     Quaternion Styles
     -----------------

     There are different &quot;styles&quot; of quaternions used in
     science and engineering applications. Quaternion styles
     are characterized by

     -  The order of quaternion elements

     -  The quaternion multiplication formula

     -  The convention for associating quaternions
        with rotation matrices

     Two of the commonly used styles are

        - &quot;SPICE&quot;

           &gt; Invented by Sir William Rowan Hamilton
           &gt; Frequently used in mathematics and physics textbooks

        - &quot;Engineering&quot;

           &gt; Widely used in aerospace engineering applications


     SPICELIB subroutine interfaces ALWAYS use SPICE quaternions.
     Quaternions of any other style must be converted to SPICE
     quaternions before they are passed to SPICELIB routines.


     Relationship between SPICE and Engineering Quaternions
     ------------------------------------------------------

     Let M be a rotation matrix such that for any vector V,

        M*V

     is the result of rotating V by theta radians in the
     counterclockwise direction about unit rotation axis vector A.
     Then the SPICE quaternions representing M are

        (+/-) (  cos(theta/2),
                 sin(theta/2) A(1),
                 sin(theta/2) A(2),
                 sin(theta/2) A(3)  )

     while the engineering quaternions representing M are

        (+/-) ( -sin(theta/2) A(1),
                -sin(theta/2) A(2),
                -sin(theta/2) A(3),
                 cos(theta/2)       )

     For both styles of quaternions, if a quaternion q represents
     a rotation matrix M, then -q represents M as well.

     Given an engineering quaternion

        QENG   = ( q0,  q1,  q2,  q3 )

     the equivalent SPICE quaternion is

        QSPICE = ( q3, -q0, -q1, -q2 )


     Associating SPICE Quaternions with Rotation Matrices
     ----------------------------------------------------

     Let FROM and TO be two right-handed reference frames, for
     example, an inertial frame and a spacecraft-fixed frame. Let the
     symbols

        V    ,   V
         FROM     TO

     denote, respectively, an arbitrary vector expressed relative to
     the FROM and TO frames. Let M denote the transformation matrix
     that transforms vectors from frame FROM to frame TO; then

        V   =  M * V
         TO         FROM

     where the expression on the right hand side represents left
     multiplication of the vector by the matrix.

     Then if the unit-length SPICE quaternion q represents M, where

        q = (q0, q1, q2, q3)

     the elements of M are derived from the elements of q as follows:

          +-                                                         -+
          |           2    2                                          |
          | 1 - 2*( q2 + q3 )   2*(q1*q2 - q0*q3)   2*(q1*q3 + q0*q2) |
          |                                                           |
          |                                                           |
          |                               2    2                      |
      M = | 2*(q1*q2 + q0*q3)   1 - 2*( q1 + q3 )   2*(q2*q3 - q0*q1) |
          |                                                           |
          |                                                           |
          |                                                   2    2  |
          | 2*(q1*q3 - q0*q2)   2*(q2*q3 + q0*q1)   1 - 2*( q1 + q2 ) |
          |                                                           |
          +-                                                         -+

     Note that substituting the elements of -q for those of q in the
     right hand side leaves each element of M unchanged; this shows
     that if a quaternion q represents a matrix M, then so does the
     quaternion -q.

     To map the rotation matrix M to a unit quaternion, we start by
     decomposing the rotation matrix as a sum of symmetric
     and skew-symmetric parts:

                                        2
        M = [ I  +  (1-cos(theta)) OMEGA  ] + [ sin(theta) OMEGA ]

                     symmetric                   skew-symmetric


     OMEGA is a skew-symmetric matrix of the form

                   +-             -+
                   |  0   -n3   n2 |
                   |               |
         OMEGA  =  |  n3   0   -n1 |
                   |               |
                   | -n2   n1   0  |
                   +-             -+

     The vector N of matrix entries (n1, n2, n3) is the rotation axis
     of M and theta is M's rotation angle. Note that N and theta
     are not unique.

     Let

        C = cos(theta/2)
        S = sin(theta/2)

     Then the unit quaternions Q corresponding to M are

        Q = +/- ( C, S*n1, S*n2, S*n3 )

     The mappings between quaternions and the corresponding rotations
     are carried out by the SPICELIB routines

        <a href="q2m.html">Q2M</a> {quaternion to matrix}
        <a href="m2q.html">M2Q</a> {matrix to quaternion}

     <a href="m2q.html">M2Q</a> always returns a quaternion with scalar part greater than
     or equal to zero.


     SPICE Quaternion Multiplication Formula
     ---------------------------------------

     Given a SPICE quaternion

        Q = ( q0, q1, q2, q3 )

     corresponding to rotation axis A and angle theta as above, we can
     represent Q using &quot;scalar + vector&quot; notation as follows:

        s =   q0           = cos(theta/2)

        v = ( q1, q2, q3 ) = sin(theta/2) * A

        Q = s + v

     Let Q1 and Q2 be SPICE quaternions with respective scalar
     and vector parts s1, s2 and v1, v2:

        Q1 = s1 + v1
        Q2 = s2 + v2

     We represent the dot product of v1 and v2 by

        &lt;v1, v2&gt;

     and the cross product of v1 and v2 by

        v1 x v2

     Then the SPICE quaternion product is

        Q1*Q2 = s1*s2 - &lt;v1,v2&gt;  + s1*v2 + s2*v1 + (v1 x v2)

     If Q1 and Q2 represent the rotation matrices M1 and M2
     respectively, then the quaternion product

        Q1*Q2

     represents the matrix product

        M1*M2
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for these examples may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine
     specific arithmetic implementation.

     1) Given the &quot;basis&quot; quaternions:

           QID:  ( 1.0, 0.0, 0.0, 0.0 )
           QI :  ( 0.0, 1.0, 0.0, 0.0 )
           QJ :  ( 0.0, 0.0, 1.0, 0.0 )
           QK :  ( 0.0, 0.0, 0.0, 1.0 )

        the following quaternion products give these results:

            Product       Expected result
           -----------   ----------------------
            QI  * QJ     ( 0.0, 0.0, 0.0, 1.0 )
            QJ  * QK     ( 0.0, 1.0, 0.0, 0.0 )
            QK  * QI     ( 0.0, 0.0, 1.0, 0.0 )
            QI  * QI     (-1.0, 0.0, 0.0, 0.0 )
            QJ  * QJ     (-1.0, 0.0, 0.0, 0.0 )
            QK  * QK     (-1.0, 0.0, 0.0, 0.0 )
            QID * QI     ( 0.0, 1.0, 0.0, 0.0 )
            QI  * QID    ( 0.0, 1.0, 0.0, 0.0 )
            QID * QJ     ( 0.0, 0.0, 1.0, 0.0 )

        The following code example uses <b>QXQ</b> to produce these results.


        Example code begins here.


              PROGRAM QXQ_EX1
              IMPLICIT NONE

        C
        C     Local variables
        C
              DOUBLE PRECISION      QID    ( 0 : 3 )
              DOUBLE PRECISION      QI     ( 0 : 3 )
              DOUBLE PRECISION      QJ     ( 0 : 3 )
              DOUBLE PRECISION      QK     ( 0 : 3 )
              DOUBLE PRECISION      QOUT   ( 0 : 3 )

        C
        C     Let QID, QI, QJ, QK be the &quot;basis&quot;
        C     quaternions.
        C
              DATA                  QID  / 1.D0,  0.D0,  0.D0,  0.D0 /
              DATA                  QI   / 0.D0,  1.D0,  0.D0,  0.D0 /
              DATA                  QJ   / 0.D0,  0.D0,  1.D0,  0.D0 /
              DATA                  QK   / 0.D0,  0.D0,  0.D0,  1.D0 /

        C
        C     Compute:
        C
        C        QI x QJ = QK
        C        QJ x QK = QI
        C        QK x QI = QJ
        C
              CALL <b>QXQ</b> ( QI, QJ, QOUT )
              WRITE(*,'(A,4F8.2)') 'QI x QJ  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QK  =', QK
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QJ, QK, QOUT )
              WRITE(*,'(A,4F8.2)') 'QJ x QK  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QI  =', QI
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QK, QI, QOUT )
              WRITE(*,'(A,4F8.2)') 'QK x QI  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QJ  =', QJ
              WRITE(*,*) ' '

        C
        C     Compute:
        C
        C        QI x QI  ==  -QID
        C        QJ x QJ  ==  -QID
        C        QK x QK  ==  -QID
        C
              CALL <b>QXQ</b> ( QI, QI, QOUT )
              WRITE(*,'(A,4F8.2)') 'QI x QI  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QID =', QID
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QJ, QJ, QOUT )
              WRITE(*,'(A,4F8.2)') 'QJ x QJ  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QID =', QID
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QK, QK, QOUT )
              WRITE(*,'(A,4F8.2)') 'QK x QK  =', QOUT
              WRITE(*,'(A,4F8.2)') '     QID =', QID
              WRITE(*,*) ' '

        C
        C     Compute:
        C
        C        QID x QI  = QI
        C        QI  x QID = QI
        C        QID x QJ  = QJ
        C
              CALL <b>QXQ</b> ( QID, QI, QOUT )
              WRITE(*,'(A,4F8.2)') 'QID x QI =', QOUT
              WRITE(*,'(A,4F8.2)') '      QI =', QI
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QI, QID, QOUT )
              WRITE(*,'(A,4F8.2)') 'QI x QID =', QOUT
              WRITE(*,'(A,4F8.2)') '      QI =', QI
              WRITE(*,*) ' '

              CALL <b>QXQ</b> ( QID, QJ, QOUT )
              WRITE(*,'(A,4F8.2)') 'QID x QJ =', QOUT
              WRITE(*,'(A,4F8.2)') '      QJ =', QJ
              WRITE(*,*) ' '

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, the output was:


        QI x QJ  =    0.00    0.00    0.00    1.00
             QK  =    0.00    0.00    0.00    1.00

        QJ x QK  =    0.00    1.00    0.00    0.00
             QI  =    0.00    1.00    0.00    0.00

        QK x QI  =    0.00    0.00    1.00    0.00
             QJ  =    0.00    0.00    1.00    0.00

        QI x QI  =   -1.00    0.00    0.00    0.00
             QID =    1.00    0.00    0.00    0.00

        QJ x QJ  =   -1.00    0.00    0.00    0.00
             QID =    1.00    0.00    0.00    0.00

        QK x QK  =   -1.00    0.00    0.00    0.00
             QID =    1.00    0.00    0.00    0.00

        QID x QI =    0.00    1.00    0.00    0.00
              QI =    0.00    1.00    0.00    0.00

        QI x QID =    0.00    1.00    0.00    0.00
              QI =    0.00    1.00    0.00    0.00

        QID x QJ =    0.00    0.00    1.00    0.00
              QJ =    0.00    0.00    1.00    0.00


     2) Compute the composition of two rotation matrices by
        converting them to quaternions and computing their
        product, and by directly multiplying the matrices.

        Example code begins here.


              PROGRAM QXQ_EX2
              IMPLICIT NONE

        C
        C     Local variables
        C
              DOUBLE PRECISION      CMAT1  ( 3,  3 )
              DOUBLE PRECISION      CMAT2  ( 3,  3 )
              DOUBLE PRECISION      CMOUT  ( 3,  3 )
              DOUBLE PRECISION      Q1     ( 0 : 3 )
              DOUBLE PRECISION      Q2     ( 0 : 3 )
              DOUBLE PRECISION      QOUT   ( 0 : 3 )

              INTEGER               I

              DATA                  CMAT1  /  1.D0,  0.D0,  0.D0,
             .                                0.D0, -1.D0,  0.D0,
             .                                0.D0,  0.D0, -1.D0  /

              DATA                  CMAT2  /  0.D0,  1.D0,  0.D0,
             .                                1.D0,  0.D0,  0.D0,
             .                                0.D0,  0.D0, -1.D0  /


        C
        C     Convert the C-matrices to quaternions.
        C
              CALL <a href="m2q.html">M2Q</a> ( CMAT1, Q1 )
              CALL <a href="m2q.html">M2Q</a> ( CMAT2, Q2 )

        C
        C     Find the product.
        C
              CALL <b>QXQ</b> ( Q1, Q2, QOUT )

        C
        C     Convert the result to a C-matrix.
        C
              CALL <a href="q2m.html">Q2M</a> ( QOUT, CMOUT )

              WRITE(*,'(A)') 'Using quaternion product:'
              WRITE(*,'(3F10.4)') (CMOUT(1,I), I = 1, 3)
              WRITE(*,'(3F10.4)') (CMOUT(2,I), I = 1, 3)
              WRITE(*,'(3F10.4)') (CMOUT(3,I), I = 1, 3)

        C
        C     Multiply CMAT1 and CMAT2 directly.
        C
              CALL <a href="mxm.html">MXM</a> ( CMAT1, CMAT2, CMOUT )

              WRITE(*,'(A)') 'Using matrix product:'
              WRITE(*,'(3F10.4)') (CMOUT(1,I), I = 1, 3)
              WRITE(*,'(3F10.4)') (CMOUT(2,I), I = 1, 3)
              WRITE(*,'(3F10.4)') (CMOUT(3,I), I = 1, 3)

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, the output was:


        Using quaternion product:
            0.0000    1.0000    0.0000
           -1.0000    0.0000    0.0000
            0.0000    0.0000    1.0000
        Using matrix product:
            0.0000    1.0000    0.0000
           -1.0000    0.0000    0.0000
            0.0000    0.0000    1.0000
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman       (JPL)
     J. Diaz del Rio    (ODC Space)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.0.2, 06-JUL-2021 (JDR)

        Edited the header to comply with NAIF standard.
        Created complete code examples from existing example and
        code fragments.

    SPICELIB Version 1.0.1, 26-FEB-2008 (NJB)

        Updated header; added information about SPICE
        quaternion conventions.

    SPICELIB Version 1.0.0, 18-AUG-2002 (NJB)</PRE>
<h4>Link to routine QXQ source file <a href='../../../src/spicelib/qxq.f'>qxq.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:36:41 2021</pre>

</body>
</html>

