
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>raxisa</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>raxisa</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     RAXISA ( Rotation axis of a matrix )

     SUBROUTINE RAXISA ( MATRIX, AXIS, ANGLE )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Compute the axis of the rotation given by an input matrix
     and the angle of the rotation about that axis.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     <a href="../req/rotation.html">ROTATION</a>
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     ANGLE
     MATRIX
     ROTATION
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     IMPLICIT NONE

     DOUBLE PRECISION    MATRIX ( 3, 3 )
     DOUBLE PRECISION    AXIS   (    3 )
     DOUBLE PRECISION    ANGLE
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     MATRIX     I   3x3 rotation matrix in double precision.
     AXIS       O   Axis of the rotation.
     ANGLE      O   Angle through which the rotation is performed.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     MATRIX   is a 3x3 rotation matrix in double precision.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     AXIS     is a unit vector pointing along the axis of the
              rotation. In other words, AXIS is a unit eigenvector
              of the input matrix, corresponding to the eigenvalue
              1. If the input matrix is the identity matrix, AXIS
              will be the vector (0, 0, 1). If the input rotation is
              a rotation by <a href="pi.html">PI</a> radians, both AXIS and -AXIS may be
              regarded as the axis of the rotation.

     ANGLE    is the angle between V and MATRIX*V for any non-zero
              vector V orthogonal to AXIS. Angle is given in
              radians. The angle returned will be in the range from
              0 to <a href="pi.html">PI</a>.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     1)  If the input matrix is not a rotation matrix (where a fairly
         loose tolerance is used to check this), an error is signaled
         by a routine in the call tree of this routine.

     2)  If the input matrix is the identity matrix, this routine
         returns an angle of 0.0, and an axis of ( 0.0, 0.0, 1.0 ).
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     Every rotation matrix has an axis A such any vector, V, parallel
     to that axis satisfies the equation

        V = MATRIX * V

     This routine returns a unit vector AXIS parallel to the axis of
     the input rotation matrix. Moreover for any vector W orthogonal
     to the axis of the rotation

        AXIS  and  W x MATRIX*W

        (where &quot;x&quot; denotes the cross product operation)

     will be positive scalar multiples of one another (at least to
     within the ability to make such computations with double
     precision arithmetic, and under the assumption that the MATRIX
     does not represent a rotation by zero or Pi radians).

     The angle returned will be the angle between W and MATRIX*W for
     any vector orthogonal to AXIS.

     If the input matrix is a rotation by 0 or <a href="pi.html">PI</a> radians some choice
     must be made for the AXIS returned. In the case of a rotation by
     0 radians, AXIS is along the positive z-axis. In the case of a
     rotation by 180 degrees, two choices are
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     The numerical results shown for these examples may differ across
     platforms. The results depend on the SPICE kernels used as
     input, the compiler and supporting libraries, and the machine
     specific arithmetic implementation.

     1) Given an axis and an angle of rotation about that axis,
        determine the rotation matrix. Using this matrix as input,
        compute the axis and angle of rotation, and verify that
        the later are equivalent by subtracting the original matrix
        and the one resulting from using the computed axis and angle
        of rotation on the <a href="axisar.html">AXISAR</a> call.


        Example code begins here.


              PROGRAM RAXISA_EX1
              IMPLICIT NONE

        C
        C     SPICELIB functions
        C
              DOUBLE PRECISION      <a href="twopi.html">TWOPI</a>

        C
        C     Local variables
        C
              DOUBLE PRECISION      ANGLE
              DOUBLE PRECISION      ANGOUT
              DOUBLE PRECISION      AXIS   ( 3    )
              DOUBLE PRECISION      AXOUT  ( 3    )
              DOUBLE PRECISION      R      ( 3, 3 )
              DOUBLE PRECISION      ROUT   ( 3, 3 )

              INTEGER               I

        C
        C     Define an axis and an angle for rotation.
        C
              DATA                  AXIS  /  1.D0, 2.D0, 3.D0  /

              ANGLE = 0.1D0 * <a href="twopi.html">TWOPI</a>()

        C
        C     Determine the rotation matrix.
        C
              CALL <a href="axisar.html">AXISAR</a> ( AXIS, ANGLE, R )

        C
        C     Now calculate the rotation axis and angle based on the
        C     matrix as input.
        C
              CALL <b>RAXISA</b> ( R, AXOUT, ANGOUT )

              WRITE(*,'(A,3F12.8)') 'Axis :', AXOUT
              WRITE(*,'(A,F12.8)')  'Angle:', ANGOUT
              WRITE(*,*) ' '

        C
        C     Now input the AXOUT and ANGOUT to <a href="axisar.html">AXISAR</a> to
        C     compare against the original rotation matrix R.
        C
              WRITE(*,'(A)') 'Difference between input and output '
             .           //  'matrices:'

              CALL <a href="axisar.html">AXISAR</a> ( AXOUT, ANGOUT, ROUT )

              DO I = 1, 3

                 WRITE(*,'(3F20.16)') ROUT(I,1) - R(I,1),
             .                        ROUT(I,2) - R(I,2),
             .                        ROUT(I,3) - R(I,3)

              END DO

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, the output was:


        Axis :  0.26726124  0.53452248  0.80178373
        Angle:  0.62831853

        Difference between input and output matrices:
         -0.0000000000000001  0.0000000000000000  0.0000000000000000
          0.0000000000000001 -0.0000000000000001  0.0000000000000000
          0.0000000000000000  0.0000000000000001  0.0000000000000000


        Note, the zero matrix is accurate to round-off error. A
        numerical demonstration of equality.


     2) This routine can be used to numerically approximate the
        instantaneous angular velocity vector of a rotating object.

        Suppose that R(t) is the rotation matrix whose columns
        represent the inertial pointing vectors of the body-fixed axes
        of an object at time t.

        Then the angular velocity vector points along the vector given
        by:

                                T
            limit  AXIS( R(t+h)R )
            h--&gt;0

        And the magnitude of the angular velocity at time t is given
        by:

                               T
           d ANGLE ( R(t+h)R(t) )
           ----------------------   at   h = 0
                     dh

        This code example computes the instantaneous angular velocity
        vector of the Earth at 2000 Jan 01 12:00:00 TDB.

        Use the PCK kernel below to load the required triaxial
        ellipsoidal shape model and orientation data for the Earth.

           pck00010.tpc


        Example code begins here.


              PROGRAM RAXISA_EX2
              IMPLICIT NONE

        C
        C     Local variables
        C
              DOUBLE PRECISION      ANGLE
              DOUBLE PRECISION      ANGVEL ( 3    )
              DOUBLE PRECISION      AXIS   ( 3    )
              DOUBLE PRECISION      INFROT ( 3, 3 )
              DOUBLE PRECISION      H
              DOUBLE PRECISION      RT     ( 3, 3 )
              DOUBLE PRECISION      RTH    ( 3, 3 )
              DOUBLE PRECISION      T

        C
        C     Load a PCK file containing a triaxial
        C     ellipsoidal shape model and orientation
        C     data for the Earth.
        C
              CALL <a href="furnsh.html">FURNSH</a> ( 'pck00010.tpc' )

        C
        C     Load time into the double precision variable T
        C     and the delta time (1 ms) into the double precision
        C     variable H
        C
              T = 0.D0
              H = 1D-3

        C
        C     Get the rotation matrices from IAU_EARTH to J2000
        C     at T and T+H.
        C
              CALL <a href="pxform.html">PXFORM</a> ( 'IAU_EARTH', 'J2000', T,   RT  )
              CALL <a href="pxform.html">PXFORM</a> ( 'IAU_EARTH', 'J2000', T+H, RTH )

        C
        C     Compute the infinitesimal rotation R(t+h)R(t)**T
        C
              CALL <a href="mxmt.html">MXMT</a> ( RTH, RT, INFROT )

        C
        C     Compute the AXIS and ANGLE of the infinitesimal rotation
        C
              CALL <b>RAXISA</b> ( INFROT, AXIS, ANGLE )

        C
        C     Scale AXIS to get the angular velocity vector
        C
              CALL <a href="vscl.html">VSCL</a> ( ANGLE/H, AXIS, ANGVEL )

        C
        C     Output the results.
        C
              WRITE(*,*) 'Instantaneous angular velocity vector:'
              WRITE(*,'(3F15.10)') ANGVEL

              END


        When this program was executed on a Mac/Intel/gfortran/64-bit
        platform, the output was:


         Instantaneous angular velocity vector:
           0.0000000000   0.0000000000   0.0000729212
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1)  If the input matrix is not a rotation matrix but is close
         enough to pass the tests this routine performs on it, no error
         will be signaled, but the results may have poor accuracy.

     2)  The input matrix is taken to be an object that acts on
         (rotates) vectors---it is not regarded as a coordinate
         transformation. To find the axis and angle of a coordinate
         transformation, input the transpose of that matrix to this
         routine.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     N.J. Bachman       (JPL)
     J. Diaz del Rio    (ODC Space)
     K.R. Gehringer     (JPL)
     W.L. Taber         (JPL)
     F.S. Turner        (JPL)
     E.D. Wright        (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 2.2.0, 05-JUL-2021 (JDR)

        Added IMPLICIT NONE statement.

        Edited the header to comply with NAIF standard.
        Added complete code examples.

    SPICELIB Version 2.1.2, 02-JAN-2008 (EDW)

        Minor edit to the ANGLE declaration strictly
        identifying the constant as a double.

        From:

           ANGLE = 2.0 * DATAN2( <a href="vnorm.html">VNORM</a>(Q(1)), Q(0) )

        To:

           ANGLE = 2.D0 * DATAN2( <a href="vnorm.html">VNORM</a>(Q(1)), Q(0) )

    SPICELIB Version 2.1.1, 05-JAN-2005 (NJB)

        Minor edits and formatting changes were made.

    SPICELIB Version 2.1.0, 30-MAY-2002 (FST)

        This routine now participates in error handling properly.

    SPICELIB Version 2.0.0, 19-SEP-1999 (WLT)

        The routine was re-written so as to avoid the numerical
        instabilities present in the previous implementation for
        rotations very near zero or 180 degrees.

    SPICELIB Version 1.1.0, 29-FEB-1996 (KRG)

        The declaration for the SPICELIB function <a href="pi.html">PI</a> is now
        preceded by an EXTERNAL statement declaring <a href="pi.html">PI</a> to be an
        external function. This removes a conflict with any
        compilers that have a <a href="pi.html">PI</a> intrinsic function.

    SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (WLT)</PRE>
<h4>Link to routine RAXISA source file <a href='../../../src/spicelib/raxisa.f'>raxisa.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:36:41 2021</pre>

</body>
</html>

