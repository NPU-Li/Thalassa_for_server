
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>lstlti</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>lstlti</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Declarations">Declarations<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Detailed_Input">Detailed_Input<br></a>
              <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
     LSTLTI ( Last integer element less than )

     INTEGER FUNCTION  LSTLTI ( X, N, ARRAY )
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
     Find the index of the largest array element less than 
     a given integer X in an array of non-decreasing integers.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
     ARRAY
     SEARCH
</PRE>
<h4><a name="Declarations">Declarations</a></h4>
<PRE>
     IMPLICIT NONE

     INTEGER          X
     INTEGER          N
     INTEGER          ARRAY ( * )
</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
     VARIABLE  I/O  DESCRIPTION
     --------  ---  --------------------------------------------------
     X          I   Upper bound value to search against.
     N          I   Number of elements in ARRAY.
     ARRAY      I   Array of possible lower bounds.

     The function returns the index of the last element of ARRAY that
     is less than X.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
     X        is an integer value acting as an upper bound: the element
              of ARRAY that is the greatest element less than X is to
              be found.

     N        is the total number of elements in ARRAY.

     ARRAY    is an array of integers that forms a non-decreasing
              sequence. The elements of array need not be distinct.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
     The function returns the index of the highest-indexed element in
     the input array that is less than X. The routine assumes the array
     elements are sorted in non-decreasing order.

     Indices range from 1 to N.

     If all elements of ARRAY are greater than or equal to X, the
     routine returns the value 0. If N is less than or equal to zero,
     the routine returns the value 0.
</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
     Error free.

     1)  If N is less than or equal to zero, the function returns 0.
         This case is not treated as an error.

     2)  If the input array is not sorted in non-decreasing order, the
         output of this routine is undefined. No error is signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
     This routine uses a binary search algorithm and so requires
     at most on the order of

        log (N)
           2

     steps to compute the value of <b>LSTLTI</b>.

     Note: If you need to find the first element of the array that is
     greater than or equal to X, simply add 1 to the result returned by
     this function and check to see if the result is within the array
     bounds given by N.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
     Suppose that you have an reasonably large ordered array of
     integers, into which you want to insert a few more without
     destroying the ordering.

     Depending upon your application, it may be desirable to
     not insert duplicates, to insert duplicates before
     existing entries or to insert them after existing entries.

     The code fragment below, illustrates an insertion scheme
     that will insert duplicate items before existing items
     and simultaneously update a second parallel array of
     double precision numbers.

           get the pair to insert

           READ (*,*) KEY, VALUE

           locate the place to insert the new KEY into the sorted
           array of keys.

           LOC = <b>LSTLTI</b> ( KEY, NKEYS, KEYS ) + 1

           insert the key and its associated value into the
           KEYS and  VALUES arrays at location LOC

           CALL <a href="inslai.html">INSLAI</a> ( KEY,   1, LOC, NKEYS, KEYS   )
           CALL <a href="inslad.html">INSLAD</a> ( VALUE, 1, LOC, NVALS, VALUES )

     If at the READ statement the arrays KEYS and VALUES looked like:

           KEYS     VALUES     NKEYS = 6, NVALS = 6
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
            16       7.11D0
            18       2.14D0
            23      12.12D0

     and 9 and 33.33D3 were read into KEY and VALUE respectively
     then <a href="lstlei.html">LSTLEI</a> (KEY, NKEYS, KEYS ) would be 3 and LOC would be 4.
     After the calls to the routines <a href="inslai.html">INSLAI</a> and <a href="inslad.html">INSLAD</a> we would have

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
             9      33.33D3     &lt;===== inserted items.
            16       7.11D0
            18       2.14D0
            23      12.12D0

     If 7 and 33.33D3 were read into KEY and VALUE respectively
     then again <a href="lstlei.html">LSTLEI</a> (KEY, NKEYS, KEYS ) would be 2 and LOC would
     be 3. After the calls to the routines <a href="inslai.html">INSLAI</a> and <a href="inslad.html">INSLAD</a> we
     would have:

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7      33.33D3     &lt;===== inserted items.
             7       3.14D0
            16       7.11D0
            18       2.14D0
            23      12.12D0

     If we replaced the line of code

           LOC = <b>LSTLTI</b> ( KEY, NKEYS, KEYS ) + 1
     by

           LOC = <a href="lstlei.html">LSTLEI</a> ( KEY, NKEYS, KEYS ) + 1

     we would obtain a routine that inserted duplicates before
     existing entries. (<a href="lstlei.html">LSTLEI</a> is similar to <b>LSTLTI</b> except it finds
     the last occurrence of an integer less than or equal to a value.)
     Using 7 and 33.33D3 for KEY and VALUE again, the modified code
     fragment would yield the results shown below.

           KEYS     VALUES     NKEYS = 7, NVALS = 7
           ----     -------
             2       3.00D0
             5       1.00D0
             7       3.14D0
             7      33.33D3     &lt;===== inserted items.
            16       7.11D0
            18       2.14D0
            23      12.12D0


     Note: you should NOT use the code outlined above as the basis of
     a sorting algorithm. The SPICELIB routines <a href="shelli.html">SHELLI</a>, <a href="shelld.html">SHELLD</a>, <a href="shellc.html">SHELLC</a>,
     <a href="orderi.html">ORDERI</a>, <a href="orderd.html">ORDERD</a>, <a href="orderc.html">ORDERC</a>, <a href="reordi.html">REORDI</a>, <a href="reordd.html">REORDD</a> and <a href="reordc.html">REORDC</a> are much more
     efficient routines for sorting arrays or sorting a set of
     parallel arrays using one of the set as a key. The fragment
     presented here is useful for performing update insertions into
     previously ordered arrays.

     For more ideas regarding the use of this routine, see <a href="lstltc.html">LSTLTC</a>
     and <a href="lstltc.html">LSTLTC</a>.
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
     1)  If the sequence of integer numbers in the input array ARRAY is
         not non-decreasing, the program will run to completion but the
         index found will not mean anything.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
     None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
     J. Diaz del Rio    (ODC Space)
     H.A. Neilan        (JPL)
     W.L. Taber         (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
    SPICELIB Version 1.1.0, 26-OCT-2021 (JDR)

        Added IMPLICIT NONE statement.

        Edited the header to comply with NAIF standard. Removed
        unnecessary $Revisions section. Improved $Detailed_Input,
        $Detailed_Output, $Particulars, $Exceptions and $Restrictions
        sections.

    SPICELIB Version 1.0.1, 10-MAR-1992 (WLT)

        Comment section for permuted index source lines was added
        following the header.

    SPICELIB Version 1.0.0, 31-JAN-1990 (WLT) (HAN)</PRE>
<h4>Link to routine LSTLTI source file <a href='../../../src/spicelib/lstlti.f'>lstlti.f</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:36:32 2021</pre>

</body>
</html>

